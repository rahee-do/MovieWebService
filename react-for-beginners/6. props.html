<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>React for beginners</title>
</head>
<body>
<!-- ReactDOM 이 React element 들을 가져다 놓을 곳 -->
<div id="root"></div>
</body>

<!-- react, react-dom import 구문 production version -->
<script src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/prop-types@15.7.2/prop-types.js"></script>
<!-- prop-types production version
<script src="https://unpkg.com/prop-types@15.6/prop-types.min.js"></script>
-->
<!-- development version
<script src="https://unpkg.com/react@17.0.2/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.development.js"></script>
-->
<!-- Load Babel : babel 을 import 한뒤, type 을 지정해줘야 한다. -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">
    const root = document.getElementById("root");

    function PropsTypesBtn({text, fontSize = 12}) {
        return (
            <button
                style={{
                    backgroundColor: "gray",
                    color: "white",
                    padding: "10px 20px",
                    border: 0,
                    borderRadius: 10,
                    marginRight: "5px",
                    fontSize
                }}
            >
                {text}
            </button>
        );
    }

    PropsTypesBtn.propTypes = {
        text: PropTypes.string.isRequired,
        fontSize: PropTypes.number
    }
    function PropsTypes() {
        // PropType 은 어떤 타입의 prop 을 받고 있는지를 체크해준다.
        // 1. propTypes 라이브러리 설치하기
        // 2. 속성들이 어떤 타입인지 지정해준다.
        // 컴포넌트.propTypes = {
        //    prop 이름 : PropTypes.string(prop 타입),
        //    prop 이름 : PropTypes.string.isRequired(prop 타입), // isRequired 는 필수 값 지정 (그 외 옵션 값)
        // }
        return (
            <div>
                <PropsTypesBtn text="Save Change" fontSize={18} />
                <PropsTypesBtn />
            </div>
        )
    }

    function Btn({text, changeValue}) {
        // button 이 언제 그려지는지 확인하기
        console.log(text, "was rendered");

        /*
        props 는 object 이기 때문에 "{}" 중괄호를 열어 "{text}" 로 받을 수 있다.
        function Btn(props){ ... } 로 안 받고 function Btn({text}) { ... } 로 바로 받아서 사용하면 된다.
        console.log(text);

        const { text, big, changeValue } = props;
        console.log(text === "Save Change" ? props.x : props.y);

        props 는 object 로 전달해준다.
        console.log(props);
        console.log(props.text);
        */

        return (
            <button
                style={{
                    backgroundColor: "tomato",
                    color: "white",
                    padding: "10px 20px",
                    border: 0,
                    borderRadius: 10,
                    marginRight: "5px",
                    // fontSize: big ? 18 : 14,
                }}
                onClick={changeValue}
            >
                {text}
            </button>
        );
    }
    /*
   * button 의 style 을 복붙하는 것 대신에, 보다 좀 더 설정이 가능한 컴포넌트를 만들어 주면 좋을 것이다.
   * 즉, 이 모종의 설정들을 넘겨 줄 수 있는 button 컴포넌트로 만들기
   * 아래 버튼 함수형 컴포넌트들을 text 만 다르고, style 이 같은 한 가지의 컴포넌트를 만든다면?
   function SaveBtn() {
       return <button style={{
           backgroundColor: "tomato",
           color: "white",
           padding: "10px 20px",
           border: 0,
           borderRadius: 10,
           marginRight: "10px"
       }}>Save Change</button>;
   }
   function ConfirmBtn() {
       return <button> style={{
           backgroundColor: "tomato",
           color: "white",
           padding: "10px 20px",
           border: 0,
           borderRadius: 10,
           marginRight: "10px"
       }}Confirm</button>;
   }
   * */
    // React 의 memo 함수에 컴포넌트를 담아줘서 사용.
    const MemorizedBtn = React.memo(Btn);
    function App() {
        /*
        * 부모 컴포넌트에서 state(상태) 변경되고, 상태 값이 변경될 때
        * return 되는 부분의 자식 컴포넌트들이 모두 새로 그려진다.
        * 그리고 부모의 상태를 바꾸는 함수를 만들었고,
        * 함수를 실행하는데 그것은 자식이 실행 시킨다.
        * 어떤 부분이 Btn Continue 를 다시 그리는 것인지 확인하기 (ReactJS 의 최적화 하는 방법)
        *   첫 번재 Btn 만 변경되기 때문에 두 번째 Btn 은 렌더링 안되게 처리
        * * React Memo 사용! (memorize(기억)하는 것처럼)
        *   만약 props 가 변경되지 않는다고 하면 리렌더링 시키지 않게 처리할 수 있다.
        */
        const [value, setValue] = React.useState("Save Change");
        const changeValue = () => setValue("Revert Changes");
        return (
            <div>
                <PropsTypes />
                {/* 새로운 정보를 Btn 컴포넌트에 전송하기 */}
                {/*  <Btn banana="Save Change" /> */}
                {/*
                    1. Btn({banana: "Save Change"}) 로 전달한다.
                        ReactJS 는 자동으로 이곳에 넣는 모든 property(prop) 들을 모두 오브젝트 안에 넣어준다.
                */}
                {/*s
                    2. 이 오브젝트는 컴포넌트의 첫 번째 인자로 주어지는 것이다.
                        props 는 첫 번째이자 Btn 이 전달 받는 유일한 인자이다. (오브젝트 형식)
                */}
                {/*
                    3. props 로 function 전달 + 부모 컴포넌트(App) 가 state(상태) 를 변경할 때 어떤 일이 일어나는 지 확인하기
                        3-1. App 부모 컴포넌트의 state 값을 Btn 자식 컴포넌트에 value 로 연결한 뒤, props 로 전달.
                        3-2. App 부모 컴포넌트의 onClick event 를 Btn 자식 컴포넌트에 props 로 전달.
                            실제 EventListener(이벤트리스너) 가 아니고, 이것들은 지금 prop 이름일 뿐이고 Btn 안으로 전달되고 있는 것이다.
                                button 태그에 onClick 이벤틀르 넣어줘야 이벤트 리스너이다.
                                즉 커스텀 컴포넌트에다가 onClick 이벤트를 넣는다면 그것은 이벤트 리스터가 아니다.
                        3-3.
                 */}
                {/*
                    자식 컴포넌트에 props(properties) 로 넘기는 것들은 자동적으로 return 안으로 들어가지 않는다.
                    즉 자식 컴포넌트에서 부모로부터 전달받은 props 들을 직접 넣어줘야 한다.
                */}
                <MemorizedBtn text={value} changeValue={changeValue} big={true} x={false} />
                <MemorizedBtn text="Confirm" big={false} y={true} />

                {/* 함수형 컴포넌트 */}
                {/* JSX 내부 */}
                {/*
                <SaveBtn />
                <ConfirmBtn />
                */}
            </div>
        );
    }
    ReactDOM.render(<App />, root);
</script>
<!-- type="text/babel -->
</html>
